--- a/net/minecraft/world/level/chunk/status/ChunkStatus.java
+++ b/net/minecraft/world/level/chunk/status/ChunkStatus.java
@@ -21,13 +21,15 @@
 import net.minecraft.world.level.levelgen.Heightmap;
 
 public class ChunkStatus {
+    static final ChunkStatus.LoadingTask PASSTHROUGH_LOAD_TASK = (WorldGenContext context, ChunkStatus status, ToFullChunk fullChunkConverter, ChunkAccess chunk) -> CompletableFuture.completedFuture(chunk); // Paper - rewrite chunk system
+    protected static final java.util.List<ChunkStatus> statuses = new java.util.ArrayList<>(); // Paper - rewrite chunk system
     public static final int MAX_STRUCTURE_DISTANCE = 8;
     private static final EnumSet<Heightmap.Types> PRE_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR_WG, Heightmap.Types.WORLD_SURFACE_WG);
     public static final EnumSet<Heightmap.Types> POST_FEATURES = EnumSet.of(
         Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES
     );
     public static final ChunkStatus EMPTY = register(
-        "empty", null, -1, false, PRE_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateEmpty, ChunkStatusTasks::loadPassThrough
+        "empty", null, -1, false, PRE_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateEmpty, PASSTHROUGH_LOAD_TASK // Paper - rewrite chunk system
     );
     public static final ChunkStatus STRUCTURE_STARTS = register(
         "structure_starts",
@@ -47,22 +49,22 @@
         PRE_FEATURES,
         ChunkType.PROTOCHUNK,
         ChunkStatusTasks::generateStructureReferences,
-        ChunkStatusTasks::loadPassThrough
+        PASSTHROUGH_LOAD_TASK // Paper - rewrite chunk system
     );
     public static final ChunkStatus BIOMES = register(
-        "biomes", STRUCTURE_REFERENCES, 8, false, PRE_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateBiomes, ChunkStatusTasks::loadPassThrough
+        "biomes", STRUCTURE_REFERENCES, 8, false, PRE_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateBiomes, PASSTHROUGH_LOAD_TASK // Paper - rewrite chunk system
     );
     public static final ChunkStatus NOISE = register(
-        "noise", BIOMES, 8, false, PRE_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateNoise, ChunkStatusTasks::loadPassThrough
+        "noise", BIOMES, 8, false, PRE_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateNoise, PASSTHROUGH_LOAD_TASK // Paper - rewrite chunk system
     );
     public static final ChunkStatus SURFACE = register(
-        "surface", NOISE, 8, false, PRE_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateSurface, ChunkStatusTasks::loadPassThrough
+        "surface", NOISE, 8, false, PRE_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateSurface, PASSTHROUGH_LOAD_TASK // Paper - rewrite chunk system
     );
     public static final ChunkStatus CARVERS = register(
-        "carvers", SURFACE, 8, false, POST_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateCarvers, ChunkStatusTasks::loadPassThrough
+        "carvers", SURFACE, 8, false, POST_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateCarvers, PASSTHROUGH_LOAD_TASK // Paper - rewrite chunk system
     );
     public static final ChunkStatus FEATURES = register(
-        "features", CARVERS, 8, false, POST_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateFeatures, ChunkStatusTasks::loadPassThrough
+        "features", CARVERS, 8, false, POST_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateFeatures, PASSTHROUGH_LOAD_TASK // Paper - rewrite chunk system
     );
     public static final ChunkStatus INITIALIZE_LIGHT = register(
         "initialize_light",
@@ -78,7 +80,7 @@
         "light", INITIALIZE_LIGHT, 1, true, POST_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateLight, ChunkStatusTasks::loadLight
     );
     public static final ChunkStatus SPAWN = register(
-        "spawn", LIGHT, 1, false, POST_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateSpawn, ChunkStatusTasks::loadPassThrough
+        "spawn", LIGHT, 1, false, POST_FEATURES, ChunkType.PROTOCHUNK, ChunkStatusTasks::generateSpawn, PASSTHROUGH_LOAD_TASK // Paper - rewrite chunk system
     );
     public static final ChunkStatus FULL = register(
         "full", SPAWN, 0, false, POST_FEATURES, ChunkType.LEVELCHUNK, ChunkStatusTasks::generateFull, ChunkStatusTasks::loadFull
@@ -117,6 +119,39 @@
     private final ChunkType chunkType;
     private final EnumSet<Heightmap.Types> heightmapsAfter;
 
+    // Paper start - starlight
+    public static ChunkStatus getStatus(String name) {
+        try {
+            // We need this otherwise we return EMPTY for invalid names
+            ResourceLocation key = new ResourceLocation(name);
+            return BuiltInRegistries.CHUNK_STATUS.getOptional(key).orElse(null);
+        } catch (Exception ex) {
+            return null; // invalid name
+        }
+    }
+    // Paper end - starlight
+    // Paper start - rewrite chunk system
+    public boolean isParallelCapable; // Paper
+    public int writeRadius = -1;
+    public int loadRange = 0;
+
+    private ChunkStatus nextStatus;
+
+    public final ChunkStatus getNextStatus() {
+        return this.nextStatus;
+    }
+
+    public final boolean isEmptyLoadStatus() {
+        return this.loadingTask == PASSTHROUGH_LOAD_TASK;
+    }
+
+    public final boolean isEmptyGenStatus() {
+        return this == ChunkStatus.EMPTY;
+    }
+
+    public final java.util.concurrent.atomic.AtomicBoolean warnedAboutNoImmediateComplete = new java.util.concurrent.atomic.AtomicBoolean();
+    // Paper end - rewrite chunk system
+
     private static ChunkStatus register(
         String id,
         @Nullable ChunkStatus previous,
@@ -178,6 +213,13 @@
         this.chunkType = chunkType;
         this.heightmapsAfter = heightMapTypes;
         this.index = previous == null ? 0 : previous.getIndex() + 1;
+        // Paper start
+        this.nextStatus = this;
+        if (statuses.size() > 0) {
+            statuses.get(statuses.size() - 1).nextStatus = this;
+        }
+        statuses.add(this);
+        // Paper end
     }
 
     public int getIndex() {
